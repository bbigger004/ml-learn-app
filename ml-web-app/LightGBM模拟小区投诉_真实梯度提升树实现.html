<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ•æ„Ÿäººç¾¤åŠ¨æ€ä¿ç”µ - æŠ•è¯‰é£é™©é¢„æµ‹</title>
    <!-- ä½¿ç”¨çº¯JavaScriptå®ç°çš„æ¢¯åº¦æå‡æ ‘åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <style>
      body {
        font-family: 'Microsoft YaHei', Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
        color: #2c3e50;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }
      .card {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid #3498db;
      }
      .card.high-risk {
        border-left-color: #e74c3c;
        background: #ffeaea;
      }
      .card.medium-risk {
        border-left-color: #f39c12;
        background: #fff3cd;
      }
      button {
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px;
      }
      button:hover {
        background: #2980b9;
      }
      button:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
      }
      .risk-indicator {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        color: white;
        font-weight: bold;
        margin-left: 10px;
      }
      .risk-low {
        background: #27ae60;
      }
      .risk-medium {
        background: #f39c12;
      }
      .risk-high {
        background: #e74c3c;
      }
      .feature-importance {
        margin-top: 20px;
      }
      .feature-bar {
        display: flex;
        align-items: center;
        margin: 8px 0;
      }
      .feature-name {
        width: 200px;
        font-weight: bold;
      }
      .feature-value {
        flex-grow: 1;
        height: 20px;
        background: #ecf0f1;
        border-radius: 10px;
        overflow: hidden;
      }
      .feature-fill {
        height: 100%;
        background: linear-gradient(90deg, #3498db, #2ecc71);
        transition: width 0.5s;
      }
      .loading-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 10px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ  æ•æ„Ÿäººç¾¤åŠ¨æ€ä¿ç”µ - æŠ•è¯‰é£é™©é¢„æµ‹</h1>
        <p>åŸºäºçœŸå®LightGBMæ€æƒ³çš„æ¢¯åº¦æå‡æ ‘é¢„æµ‹æ¨¡å‹</p>
      </div>

      <div class="grid">
        <div class="card">
          <h3>ğŸ“Š æ¨¡å‹è®­ç»ƒçŠ¶æ€</h3>
          <div id="trainingStatus">å‡†å¤‡å¼€å§‹è®­ç»ƒ...</div>
          <div id="trainingProgress"></div>
          <div id="modelMetrics"></div>
        </div>

        <div class="card">
          <h3>âš¡ å®æ—¶é¢„æµ‹æ§åˆ¶</h3>
          <button onclick="startTraining()">å¼€å§‹è®­ç»ƒæ¨¡å‹</button>
          <button onclick="generatePredictions()">ç”Ÿæˆç½‘æ ¼é¢„æµ‹</button>
          <button onclick="resetModel()">é‡ç½®æ¨¡å‹</button>
        </div>
      </div>

      <div class="card">
        <h3>ğŸ” é«˜é£é™©ç½‘æ ¼é¢„è­¦</h3>
        <div id="predictions"></div>
      </div>

      <div class="card">
        <h3>ğŸ“ˆ ç‰¹å¾é‡è¦æ€§åˆ†æ</h3>
        <div id="featureImportance" class="feature-importance"></div>
      </div>
    </div>

    <script>
      // æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå™¨ç±»ï¼Œç”¨äºåˆ›å»ºè®­ç»ƒæ•°æ®å’Œé¢„æµ‹æ•°æ®
      class PowerGridDataGenerator {
        constructor() {
          // å®šä¹‰æ¨¡å‹ä½¿ç”¨çš„10ä¸ªç‰¹å¾
          this.features = [
            'population_density', // äººå£å¯†åº¦
            'load_rate', // è´Ÿè½½ç‡
            'historical_faults', // å†å²æ•…éšœæ•°
            'special_group_density', // ç‰¹æ®Šç¾¤ä½“å¯†åº¦
            'equipment_age', // è®¾å¤‡è€åŒ–ç¨‹åº¦
            'external_risk', // å¤–éƒ¨é£é™©
            'holiday_flag', // æ˜¯å¦èŠ‚å‡æ—¥
            'economic_level', // ç»æµæ°´å¹³
            'historical_complaints', // å†å²æŠ•è¯‰æ•°
            'temperature', // æ¸©åº¦
          ]
        }

        // ç”Ÿæˆæ¨¡æ‹Ÿè®­ç»ƒæ•°æ®çš„æ–¹æ³•
        generateTrainingData(samples = 10000) {
          const features = []
          const labels = []

          for (let i = 0; i < samples; i++) {
            const sample = this.generateSample()
            features.push(sample.features)
            labels.push(sample.label)
          }

          return {
            features: features,
            labels: labels,
          }
        }

        // ç”Ÿæˆå•ä¸ªæ ·æœ¬çš„æ–¹æ³•
        generateSample() {
          const populationDensity = Math.random()
          const loadRate = Math.random()
          const historicalFaults = Math.floor(Math.random() * 10)
          const specialGroupDensity = Math.random()
          const equipmentAge = Math.random()
          const externalRisk = Math.random()
          const holidayFlag = Math.random() > 0.7 ? 1 : 0
          const economicLevel = Math.random()
          const historicalComplaints = Math.floor(Math.random() * 5)
          const temperature = 20 + Math.random() * 30

          const features = [
            populationDensity,
            loadRate,
            historicalFaults / 10,
            specialGroupDensity,
            equipmentAge,
            externalRisk,
            holidayFlag,
            economicLevel,
            historicalComplaints / 5,
            (temperature - 20) / 30,
          ]

          // åŸºäºä¸šåŠ¡è§„åˆ™ç”Ÿæˆæ ‡ç­¾
          let complaintProbability = 0
          complaintProbability += populationDensity * 0.15
          complaintProbability += loadRate * 0.2
          complaintProbability += (historicalFaults / 10) * 0.15
          complaintProbability += specialGroupDensity * 0.25
          complaintProbability += equipmentAge * 0.1
          complaintProbability += externalRisk * 0.08
          complaintProbability += holidayFlag * 0.05
          complaintProbability += economicLevel * 0.02
          complaintProbability += (Math.random() - 0.5) * 0.1

          const label = complaintProbability > 0.5 ? 1 : 0
          return { features, label }
        }

        // ç”Ÿæˆæ¨¡æ‹Ÿé¢„æµ‹æ•°æ®
        generatePredictionData(gridCount = 20) {
          const grids = []
          for (let i = 0; i < gridCount; i++) {
            const sample = this.generateSample()
            grids.push({
              id: `GRID_${(i + 1).toString().padStart(3, '0')}`,
              features: sample.features,
              riskLevel: 'pending',
            })
          }
          return grids
        }
      }

      // çº¯JavaScriptå®ç°çš„æ¢¯åº¦æå‡æ ‘é¢„æµ‹æ¨¡å‹ç±»
      class JavaScriptGradientBoostingModel {
        constructor() {
          this.trees = []              // å­˜å‚¨å†³ç­–æ ‘é›†åˆ
          this.isTrained = false       // æ¨¡å‹æ˜¯å¦å·²è®­ç»ƒæ ‡å¿—
          this.featureImportance = null // ç‰¹å¾é‡è¦æ€§
          this.learningRate = 0.1      // å­¦ä¹ ç‡
          this.numTrees = 0            // æ ‘çš„æ•°é‡
          this.maxDepth = 0            // æ ‘çš„æœ€å¤§æ·±åº¦
        }

        // è®­ç»ƒæ¢¯åº¦æå‡æ ‘æ¨¡å‹
        async train(features, labels, numTrees = 100, maxDepth = 6) {
          try {
            this.learningRate = 0.1
            this.numTrees = numTrees
            this.maxDepth = maxDepth
            this.trees = []
            
            // åˆå§‹åŒ–é¢„æµ‹å€¼ä¸º0
            let predictions = Array(labels.length).fill(0)
            
            // è½¬æ¢æ ‡ç­¾ä¸ºæ¦‚ç‡å€¼çš„å¯¹æ•°å‡ ç‡å½¢å¼ï¼ˆç”¨äºlogisticå›å½’ï¼‰
            let residuals = labels.map(y => y - 0.5) // åˆå§‹æ®‹å·®
            
            // å¾ªç¯æ„å»ºå¤šæ£µå†³ç­–æ ‘
            for (let treeIndex = 0; treeIndex < numTrees; treeIndex++) {
              // æ›´æ–°è®­ç»ƒçŠ¶æ€
              document.getElementById(
                'trainingStatus'
              ).innerHTML = `<span class="loading-spinner"></span>è®­ç»ƒä¸­... ç¬¬ ${treeIndex + 1}/${numTrees} è½®`
              console.log('this.trees',this.trees)
              // è®¡ç®—å½“å‰è®­ç»ƒè¯¯å·®
              const currentError = this.calculateError(predictions, labels)
              document.getElementById('trainingProgress').innerHTML = 
                `è®­ç»ƒè¯¯å·®: ${currentError.toFixed(4)}`
              
              // æ„å»ºä¸€æ£µå†³ç­–æ ‘æ¥æ‹Ÿåˆæ®‹å·®
              const tree = this.buildDecisionTree(features, residuals, 0, maxDepth)
              this.trees.push(tree)
              
              // æ›´æ–°é¢„æµ‹å€¼ï¼ˆç´¯åŠ å­¦ä¹ ç‡*æ–°æ ‘çš„é¢„æµ‹ç»“æœï¼‰
              for (let i = 0; i < features.length; i++) {
                const treePrediction = this.predictWithTree(tree, features[i])
                predictions[i] += this.learningRate * treePrediction
                // æ›´æ–°æ®‹å·®ï¼ˆä½¿ç”¨æ¢¯åº¦æå‡çš„æ€æƒ³ï¼‰
                const prob = 1 / (1 + Math.exp(-predictions[i])) // sigmoidå˜æ¢
                residuals[i] = labels[i] - prob
              }
              
              // é¿å…UIå¡é¡¿
              if (treeIndex % 5 === 0) {
                await new Promise(resolve => setTimeout(resolve, 10))
              }
            }
            
            // è®¡ç®—ç‰¹å¾é‡è¦æ€§
            this.calculateFeatureImportance()
            
            // è®¾ç½®è®­ç»ƒå®Œæˆæ ‡å¿—
            this.isTrained = true
            return this.trees
      
          } catch (error) {
            console.error('è®­ç»ƒé”™è¯¯:', error)
            throw error
          }
        }
        
        // æ„å»ºå†³ç­–æ ‘ï¼ˆé€’å½’å‡½æ•°ï¼‰
        buildDecisionTree(features, residuals, depth, maxDepth) {
          // å¦‚æœè¾¾åˆ°æœ€å¤§æ·±åº¦æˆ–è€…æ•°æ®å¤ªå°‘ï¼Œè¿”å›å¶èŠ‚ç‚¹
          if (depth >= maxDepth || features.length <= 4) {
            return {
              type: 'leaf',
              value: this.calculateLeafValue(residuals)
            }
          }
          
          // å¯»æ‰¾æœ€ä½³åˆ†å‰²ç‚¹
          let bestFeatureIndex = -1
          let bestThreshold = 0
          let bestGain = -Infinity
          let bestLeftIndices = []
          let bestRightIndices = []
          
          // éå†æ‰€æœ‰ç‰¹å¾å¯»æ‰¾æœ€ä½³åˆ†å‰²
          for (let featureIndex = 0; featureIndex < features[0].length; featureIndex++) {
            // å¯¹ç‰¹å¾å€¼æ’åºå¹¶å»é‡ï¼Œå¯»æ‰¾å¯èƒ½çš„åˆ†å‰²ç‚¹
            const featureValues = [...new Set(features.map(row => row[featureIndex]))].sort((a, b) => a - b)
            
            // å°è¯•æ¯ä¸ªåˆ†å‰²ç‚¹
            for (let i = 1; i < featureValues.length; i++) {
              const threshold = (featureValues[i-1] + featureValues[i]) / 2
              
              // åˆ†å‰²æ•°æ®
              const leftIndices = []
              const rightIndices = []
              for (let j = 0; j < features.length; j++) {
                if (features[j][featureIndex] <= threshold) {
                  leftIndices.push(j)
                } else {
                  rightIndices.push(j)
                }
              }
              
              // è®¡ç®—åˆ†å‰²å¢ç›Š
              const gain = this.calculateSplitGain(residuals, leftIndices, rightIndices)
              
              if (gain > bestGain) {
                bestGain = gain
                bestFeatureIndex = featureIndex
                bestThreshold = threshold
                bestLeftIndices = leftIndices
                bestRightIndices = rightIndices
              }
            }
          }
          
          // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æœ‰æ„ä¹‰çš„åˆ†å‰²ï¼Œè¿”å›å¶èŠ‚ç‚¹
          if (bestGain <= 0 || bestLeftIndices.length === 0 || bestRightIndices.length === 0) {
            return {
              type: 'leaf',
              value: this.calculateLeafValue(residuals)
            }
          }
          
          // é€’å½’æ„å»ºå·¦å³å­æ ‘
          const leftFeatures = bestLeftIndices.map(i => features[i])
          const leftResiduals = bestLeftIndices.map(i => residuals[i])
          const rightFeatures = bestRightIndices.map(i => features[i])
          const rightResiduals = bestRightIndices.map(i => residuals[i])
          
          return {
            type: 'node',
            featureIndex: bestFeatureIndex,
            threshold: bestThreshold,
            left: this.buildDecisionTree(leftFeatures, leftResiduals, depth + 1, maxDepth),
            right: this.buildDecisionTree(rightFeatures, rightResiduals, depth + 1, maxDepth)
          }
        }
        
        // è®¡ç®—å¶èŠ‚ç‚¹å€¼
        calculateLeafValue(residuals) {
          // å¯¹äºæ¢¯åº¦æå‡æ ‘ï¼Œå¶èŠ‚ç‚¹å€¼æ˜¯æ®‹å·®çš„å‡å€¼
          return residuals.reduce((sum, val) => sum + val, 0) / residuals.length
        }
        
        // è®¡ç®—åˆ†å‰²å¢ç›Š
        calculateSplitGain(residuals, leftIndices, rightIndices) {
          // è®¡ç®—çˆ¶èŠ‚ç‚¹æ–¹å·®
          const parentVariance = this.calculateVariance(residuals)
          
          // è®¡ç®—å·¦å³å­èŠ‚ç‚¹æ–¹å·®
          const leftResiduals = leftIndices.map(i => residuals[i])
          const rightResiduals = rightIndices.map(i => residuals[i])
          const leftVariance = this.calculateVariance(leftResiduals)
          const rightVariance = this.calculateVariance(rightResiduals)
          
          // è®¡ç®—ä¿¡æ¯å¢ç›Š
          const leftWeight = leftResiduals.length / residuals.length
          const rightWeight = rightResiduals.length / residuals.length
          const gain = parentVariance - (leftWeight * leftVariance + rightWeight * rightVariance)
          
          return gain
        }
        
        // è®¡ç®—æ–¹å·®
        calculateVariance(values) {
          if (values.length === 0) return 0
          const mean = values.reduce((sum, val) => sum + val, 0) / values.length
          return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length
        }
        
        // è®¡ç®—è®­ç»ƒè¯¯å·®
        calculateError(predictions, labels) {
          let errorCount = 0
          for (let i = 0; i < predictions.length; i++) {
            // å°†é¢„æµ‹å€¼è½¬æ¢ä¸ºæ¦‚ç‡
            const prob = 1 / (1 + Math.exp(-predictions[i]))
            // äºŒåˆ†ç±»é¢„æµ‹ï¼šæ¦‚ç‡>0.5ä¸º1ï¼Œå¦åˆ™ä¸º0
            const predictedClass = prob > 0.5 ? 1 : 0
            if (predictedClass !== labels[i]) {
              errorCount++
            }
          }
          return errorCount / predictions.length
        }
        
        // ä½¿ç”¨å•æ£µæ ‘è¿›è¡Œé¢„æµ‹
        predictWithTree(tree, features) {
          if (tree.type === 'leaf') {
            return tree.value
          }
          
          if (features[tree.featureIndex] <= tree.threshold) {
            return this.predictWithTree(tree.left, features)
          } else {
            return this.predictWithTree(tree.right, features)
          }
        }
        
        // è®¡ç®—ç‰¹å¾é‡è¦æ€§
        calculateFeatureImportance() {
          // å®šä¹‰ç‰¹å¾çš„ä¸­æ–‡åç§°
          const featureNames = [
            'äººå£å¯†åº¦',
            'è´Ÿè½½ç‡',
            'å†å²æ•…éšœæ•°',
            'ç‰¹æ®Šç¾¤ä½“å¯†åº¦',
            'è®¾å¤‡è€åŒ–ç¨‹åº¦',
            'å¤–éƒ¨é£é™©',
            'æ˜¯å¦èŠ‚å‡æ—¥',
            'ç»æµæ°´å¹³',
            'å†å²æŠ•è¯‰æ•°',
            'æ¸©åº¦',
          ]
          
          // åˆå§‹åŒ–ç‰¹å¾é‡è¦æ€§è®¡æ•°
          const importanceCount = Array(10).fill(0)
          
          // ç»Ÿè®¡æ¯ä¸ªç‰¹å¾åœ¨æ‰€æœ‰æ ‘ä¸­çš„å‡ºç°æ¬¡æ•°ï¼ˆç®€åŒ–çš„é‡è¦æ€§è®¡ç®—ï¼‰
          const countFeatureUsage = (tree) => {
            if (tree.type === 'node') {
              importanceCount[tree.featureIndex]++
              countFeatureUsage(tree.left)
              countFeatureUsage(tree.right)
            }
          }
          
          // éå†æ‰€æœ‰æ ‘
          this.trees.forEach(tree => countFeatureUsage(tree))
          
          // æ ‡å‡†åŒ–å¹¶åˆ›å»ºé‡è¦æ€§å¯¹è±¡æ•°ç»„
          const maxCount = Math.max(...importanceCount)
          this.featureImportance = featureNames.map((name, index) => ({
            name,
            importance: maxCount > 0 ? importanceCount[index] / maxCount : 0
          })).sort((a, b) => b.importance - a.importance)
        }

        // æ¨¡æ‹Ÿç‰¹å¾é‡è¦æ€§ï¼ˆå½“çœŸå®è®¡ç®—ä¸å¯ç”¨æ—¶ï¼‰
        getMockFeatureImportance() {
          const featureNames = [
            'äººå£å¯†åº¦',
            'è´Ÿè½½ç‡',
            'å†å²æ•…éšœæ•°',
            'ç‰¹æ®Šç¾¤ä½“å¯†åº¦',
            'è®¾å¤‡è€åŒ–ç¨‹åº¦',
            'å¤–éƒ¨é£é™©',
            'æ˜¯å¦èŠ‚å‡æ—¥',
            'ç»æµæ°´å¹³',
            'å†å²æŠ•è¯‰æ•°',
            'æ¸©åº¦',
          ]

          // æ ¹æ®ä¸šåŠ¡é€»è¾‘è®¾ç½®æ¨¡æ‹Ÿçš„é‡è¦æ€§
          return [
            { name: 'ç‰¹æ®Šç¾¤ä½“å¯†åº¦', importance: 0.95 },
            { name: 'è´Ÿè½½ç‡', importance: 0.85 },
            { name: 'å†å²æ•…éšœæ•°', importance: 0.75 },
            { name: 'äººå£å¯†åº¦', importance: 0.70 },
            { name: 'è®¾å¤‡è€åŒ–ç¨‹åº¦', importance: 0.55 },
            { name: 'å¤–éƒ¨é£é™©', importance: 0.45 },
            { name: 'æ˜¯å¦èŠ‚å‡æ—¥', importance: 0.35 },
            { name: 'å†å²æŠ•è¯‰æ•°', importance: 0.30 },
            { name: 'æ¸©åº¦', importance: 0.25 },
            { name: 'ç»æµæ°´å¹³', importance: 0.20 }
          ]
        }

        // é¢„æµ‹ç½‘æ ¼é£é™©çš„æ–¹æ³•
        async predict(grids) {
          if (!this.isTrained) {
            throw new Error('æ¨¡å‹å°šæœªè®­ç»ƒï¼Œè¯·å…ˆè®­ç»ƒæ¨¡å‹')
          }

          try {
            // æå–æ‰€æœ‰ç½‘æ ¼çš„ç‰¹å¾æ•°æ®
            const featuresArray = grids.map((grid) => grid.features)
            
            // è½¬æ¢ä¸ºDMatrixæ ¼å¼
            const dtest = await xgboost.DMatrix({
              data: featuresArray
            })

            // ä½¿ç”¨æ¨¡å‹è¿›è¡Œé¢„æµ‹
            const predictions = await this.booster.predict(dtest)

            // ä¸ºæ¯ä¸ªç½‘æ ¼æ·»åŠ é¢„æµ‹ç»“æœ
            return grids.map((grid, index) => {
              const riskScore = predictions[index]
              let riskLevel, riskClass

              if (riskScore < 0.3) {
                riskLevel = 'ä½é£é™©'
                riskClass = 'risk-low'
              } else if (riskScore < 0.7) {
                riskLevel = 'ä¸­é£é™©'
                riskClass = 'risk-medium'
              } else {
                riskLevel = 'é«˜é£é™©'
                riskClass = 'risk-high'
              }

              return {
                ...grid,
                riskScore: riskScore,
                riskLevel: riskLevel,
                riskClass: riskClass,
              }
            })
          } catch (error) {
            console.error('é¢„æµ‹é”™è¯¯:', error)
            // å¦‚æœXGBoosté¢„æµ‹å¤±è´¥ï¼Œä½¿ç”¨ç®€åŒ–çš„è§„åˆ™é¢„æµ‹ä½œä¸ºåå¤‡
            return this.fallbackPredict(grids)
          }
        }

        // ä½¿ç”¨æ¨¡å‹è¿›è¡Œé¢„æµ‹
        async predict(grids) {
          if (!this.isTrained) {
            throw new Error('æ¨¡å‹å°šæœªè®­ç»ƒï¼Œè¯·å…ˆè®­ç»ƒæ¨¡å‹')
          }

          try {
            return grids.map(grid => {
              // åˆå§‹åŒ–é¢„æµ‹å€¼
              let prediction = 0
              
              // éå†æ‰€æœ‰æ ‘è¿›è¡Œé¢„æµ‹å¹¶ç´¯åŠ ç»“æœ
              this.trees.forEach(tree => {
                prediction += this.learningRate * this.predictWithTree(tree, grid.features)
              })
              
              // ä½¿ç”¨sigmoidå‡½æ•°å°†é¢„æµ‹å€¼è½¬æ¢ä¸ºæ¦‚ç‡
              const riskScore = 1 / (1 + Math.exp(-prediction))
              
              let riskLevel, riskClass
              if (riskScore < 0.3) {
                riskLevel = 'ä½é£é™©'
                riskClass = 'risk-low'
              } else if (riskScore < 0.7) {
                riskLevel = 'ä¸­é£é™©'
                riskClass = 'risk-medium'
              } else {
                riskLevel = 'é«˜é£é™©'
                riskClass = 'risk-high'
              }

              return {
                ...grid,
                riskScore: riskScore,
                riskLevel: riskLevel,
                riskClass: riskClass,
                isGradientBoosting: true // æ ‡è®°è¿™æ˜¯ä½¿ç”¨æ¢¯åº¦æå‡æ ‘çš„é¢„æµ‹
              }
            })
          } catch (error) {
            console.error('é¢„æµ‹é”™è¯¯:', error)
            // å¦‚æœé¢„æµ‹å¤±è´¥ï¼Œä½¿ç”¨ç®€åŒ–çš„è§„åˆ™é¢„æµ‹ä½œä¸ºåå¤‡
            return this.simplifiedPredict(grids)
          }
        }
        
        // ç®€åŒ–çš„é¢„æµ‹æ–¹æ³•ï¼ˆå½“æ¢¯åº¦æå‡æ ‘é¢„æµ‹å¤±è´¥æ—¶ï¼‰
        simplifiedPredict(grids) {
          console.log('ä½¿ç”¨ç®€åŒ–çš„è§„åˆ™é¢„æµ‹ä½œä¸ºåå¤‡æ–¹æ¡ˆ')
          return grids.map(grid => {
            // æå–å…³é”®ç‰¹å¾
            const [populationDensity, loadRate, historicalFaults, 
                   specialGroupDensity, equipmentAge, externalRisk,
                   holidayFlag] = grid.features
            
            // ä½¿ç”¨åŸºäºä¸šåŠ¡è§„åˆ™çš„é¢„æµ‹
            let riskScore = 0
            riskScore += specialGroupDensity * 0.35  // ç‰¹æ®Šç¾¤ä½“å¯†åº¦æƒé‡æœ€é«˜
            riskScore += loadRate * 0.25             // è´Ÿè½½ç‡æƒé‡é«˜
            riskScore += historicalFaults * 0.15     // å†å²æ•…éšœæ•°æƒé‡ä¸­ç­‰
            riskScore += populationDensity * 0.10    // äººå£å¯†åº¦æƒé‡ä¸­ç­‰
            riskScore += equipmentAge * 0.08         // è®¾å¤‡è€åŒ–æƒé‡è¾ƒä½
            riskScore += externalRisk * 0.05         // å¤–éƒ¨é£é™©æƒé‡è¾ƒä½
            riskScore += holidayFlag * 0.02          // èŠ‚å‡æ—¥æƒé‡æœ€ä½
            
            // é™åˆ¶åœ¨0-1èŒƒå›´å†…
            riskScore = Math.max(0, Math.min(1, riskScore))
            
            let riskLevel, riskClass
            if (riskScore < 0.3) {
              riskLevel = 'ä½é£é™©'
              riskClass = 'risk-low'
            } else if (riskScore < 0.7) {
              riskLevel = 'ä¸­é£é™©'
              riskClass = 'risk-medium'
            } else {
              riskLevel = 'é«˜é£é™©'
              riskClass = 'risk-high'
            }

            return {
              ...grid,
              riskScore: riskScore,
              riskLevel: riskLevel,
              riskClass: riskClass,
              isSimplified: true // æ ‡è®°è¿™æ˜¯ä½¿ç”¨ç®€åŒ–è§„åˆ™çš„é¢„æµ‹
            }
          })
        }

        // ä¿å­˜æ¨¡å‹çš„æ–¹æ³•
        async saveModel() {
          if (!this.isTrained) {
            throw new Error('æ²¡æœ‰å¯ä¿å­˜çš„æ¨¡å‹')
          }
          
          // å°†æ¨¡å‹è½¬æ¢ä¸ºJSONæ ¼å¼
          const modelData = {
            trees: this.trees,
            learningRate: this.learningRate,
            featureImportance: this.featureImportance
          }
          
          // è¿”å›JSONå­—ç¬¦ä¸²
          return JSON.stringify(modelData)
        }

        // åŠ è½½æ¨¡å‹çš„æ–¹æ³•
        async loadModel(jsonModel) {
          try {
            const modelData = JSON.parse(jsonModel)
            this.trees = modelData.trees
            this.learningRate = modelData.learningRate
            this.featureImportance = modelData.featureImportance
            this.isTrained = true
            return true
          } catch (error) {
            console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error)
            return false
          }
        }
      }

      // åˆ›å»ºå…¨å±€å˜é‡å®ä¾‹
      let dataGenerator = new PowerGridDataGenerator()
      let predictionModel = new JavaScriptGradientBoostingModel()
      let currentGrids = []

      // å¼€å§‹è®­ç»ƒæ¨¡å‹çš„å‡½æ•°
      async function startTraining() {
        try {
          document.getElementById('trainingStatus').innerHTML = 
            '<span class="loading-spinner"></span>ç”Ÿæˆè®­ç»ƒæ•°æ®ä¸­...'

          // ç”Ÿæˆ5000ä¸ªè®­ç»ƒæ ·æœ¬
          const trainingData = dataGenerator.generateTrainingData(5000)
          document.getElementById('trainingStatus').innerHTML = 
            '<span class="loading-spinner"></span>æ•°æ®ç”Ÿæˆå®Œæˆï¼Œå¼€å§‹è®­ç»ƒæ¢¯åº¦æå‡æ ‘æ¨¡å‹...'

          // è®­ç»ƒLightGBMæ¨¡å‹
          await predictionModel.train(
            trainingData.features,
            trainingData.labels,
            50,  // æ ‘çš„æ•°é‡
            6    // æœ€å¤§æ·±åº¦
          )

          document.getElementById('trainingStatus').innerHTML = 
            '<span style="color: green;">âœ… æ¢¯åº¦æå‡æ ‘æ¨¡å‹è®­ç»ƒå®Œæˆï¼</span>'
          document.getElementById('modelMetrics').innerHTML = 
            'æ¨¡å‹å·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹é¢„æµ‹ç½‘æ ¼é£é™©'

        } catch (error) {
          console.error('è®­ç»ƒå¤±è´¥:', error)
          document.getElementById(
            'trainingStatus'
          ).innerHTML = `<span style="color: red;">è®­ç»ƒå¤±è´¥: ${error.message}</span>`
          
          // å¦‚æœXGBoostè®­ç»ƒå¤±è´¥ï¼Œæ˜¾ç¤ºå‹å¥½æç¤ºå¹¶è¯´æ˜å°†ä½¿ç”¨åå¤‡æ–¹æ¡ˆ
          if (error.message.includes('xgboost')) {
            document.getElementById('modelMetrics').innerHTML = 
              '<span style="color: orange;">æ³¨æ„ï¼šXGBoostè®­ç»ƒå¤±è´¥ï¼Œé¢„æµ‹æ—¶å°†ä½¿ç”¨è§„åˆ™åŒ–æ–¹æ³•ä½œä¸ºåå¤‡</span>'
            predictionModel.isTrained = true // å…è®¸ä½¿ç”¨åå¤‡é¢„æµ‹
          }
        }
      }

      // ç”Ÿæˆé¢„æµ‹ç»“æœçš„å‡½æ•°
      async function generatePredictions() {
        if (!predictionModel.isTrained) {
          alert('è¯·å…ˆè®­ç»ƒæ¨¡å‹ï¼')
          return
        }

        try {
          document.getElementById('predictions').innerHTML = 
            '<span class="loading-spinner"></span>é¢„æµ‹ä¸­...'

          // ç”Ÿæˆ15ä¸ªç½‘æ ¼çš„æ¨¡æ‹Ÿæ•°æ®
          currentGrids = dataGenerator.generatePredictionData(15)

          // ä½¿ç”¨æ¨¡å‹è¿›è¡Œé¢„æµ‹
          const predictions = await predictionModel.predict(currentGrids)

          // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
          displayPredictions(predictions)

          // æ˜¾ç¤ºç‰¹å¾é‡è¦æ€§åˆ†æ
          displayFeatureImportance()
        } catch (error) {
          console.error('é¢„æµ‹å¤±è´¥:', error)
          document.getElementById(
            'predictions'
          ).innerHTML = `<span style="color: red;">é¢„æµ‹å¤±è´¥: ${error.message}</span>`
        }
      }

      // æ˜¾ç¤ºé¢„æµ‹ç»“æœçš„å‡½æ•°
      function displayPredictions(predictions) {
        let html = ''

        predictions.forEach((grid) => {
          const cardClass = 
            grid.riskScore > 0.7
              ? 'high-risk'
              : grid.riskScore > 0.4
              ? 'medium-risk'
              : ''

          // ç”Ÿæˆé¢„æµ‹æ–¹æ³•æ ‡ç­¾
          let methodLabel = ''
          if (grid.isGradientBoosting) {
            methodLabel = '<span style="color: #27ae60; font-size: 0.8em;">(æ¢¯åº¦æå‡æ ‘)</span>'
          } else if (grid.isSimplified) {
            methodLabel = '<span style="color: #666; font-size: 0.8em;">(è§„åˆ™é¢„æµ‹)</span>'
          }

          html += `
                <div class="card ${cardClass}">
                    <h4>${grid.id} 
                        <span class="risk-indicator ${grid.riskClass}">
                            ${grid.riskLevel} (${(grid.riskScore * 100).toFixed(1)}%)
                        </span>
                        ${methodLabel}
                    </h4>
                    <p>ç‰¹å¾: äººå£å¯†åº¦ ${(grid.features[0] * 100).toFixed(1)}%, 
                        è´Ÿè½½ç‡ ${(grid.features[1] * 100).toFixed(1)}%, 
                        ç‰¹æ®Šç¾¤ä½“ ${(grid.features[3] * 100).toFixed(1)}%</p>
                </div>
                `
        })

        document.getElementById('predictions').innerHTML = html
      }

      // æ˜¾ç¤ºç‰¹å¾é‡è¦æ€§çš„å‡½æ•°
      function displayFeatureImportance() {
        // è·å–ç‰¹å¾é‡è¦æ€§æ•°æ®
        const importance = predictionModel.featureImportance || 
                          predictionModel.getMockFeatureImportance()
        let html = ''

        importance.forEach((feature) => {
          const width = feature.importance * 100 + '%'
          html += `
                <div class="feature-bar">
                    <div class="feature-name">${feature.name}</div>
                    <div class="feature-value">
                        <div class="feature-fill" style="width: ${width}"></div>
                    </div>
                    <div style="width: 60px; text-align: right;">
                        ${(feature.importance * 100).toFixed(1)}%
                    </div>
                </div>
                `
        })

        document.getElementById('featureImportance').innerHTML = html
      }

      // é‡ç½®æ¨¡å‹çš„å‡½æ•°
      function resetModel() {
        predictionModel = new JavaScriptGradientBoostingModel()
        document.getElementById('trainingStatus').innerHTML = 
          'æ¨¡å‹å·²é‡ç½®ï¼Œå‡†å¤‡å¼€å§‹è®­ç»ƒ...'
        document.getElementById('trainingProgress').innerHTML = ''
        document.getElementById('modelMetrics').innerHTML = ''
        document.getElementById('predictions').innerHTML = ''
        document.getElementById('featureImportance').innerHTML = ''
      }

      // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œçš„åˆå§‹åŒ–å‡½æ•°
      document.addEventListener('DOMContentLoaded', function () {
        console.log('æ•æ„Ÿäººç¾¤åŠ¨æ€ä¿ç”µé¢„æµ‹ç³»ç»Ÿå·²åˆå§‹åŒ–ï¼ˆåŸºäºçº¯JavaScriptæ¢¯åº¦æå‡æ ‘ï¼‰')
        console.log('ä½¿ç”¨è‡ªå®ç°çš„æ¢¯åº¦æå‡æ ‘ç®—æ³•ï¼Œæ— éœ€å¤–éƒ¨ä¾èµ–')
        
        document.getElementById('modelMetrics').innerHTML = 
          '<span style="color: #27ae60;">çº¯JavaScriptå®ç°çš„æ¢¯åº¦æå‡æ ‘å·²å‡†å¤‡å°±ç»ª</span>'
      })
    </script>
  </body>
</html>